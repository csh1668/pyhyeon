# Closure Edge Cases 테스트 (작동하는 버전)

# 테스트 1: 2단 중첩 closure
make_add = lambda x: lambda y: x + y
assert(make_add(10)(20) == 30)

# 테스트 2: 여러 변수 동시 캡처
make_func = lambda a, b: lambda c: a + b + c
assert(make_func(10, 20)(30) == 60)

# 테스트 3: Closure가 여러 closure 반환
make_ops = lambda x: [lambda: x + 1, lambda: x * 2, lambda: x * x]
funcs = make_ops(5)
assert(funcs[0]() == 6)
assert(funcs[1]() == 10)
assert(funcs[2]() == 25)

# 테스트 4: Closure와 글로벌 변수 혼합
global_multiplier = 100
make_calc = lambda x: lambda y: x + y + global_multiplier
calc = make_calc(10)
assert(calc(20) == 130)

# 테스트 5: 복잡한 표현식에서의 캡처
make_complex = lambda a, b: lambda x: (a + b) * x - a
complex_fn = make_complex(5, 10)
assert(complex_fn(2) == 25)

# 테스트 6: Closure를 변수에 저장하고 재사용
adder = lambda x: lambda y: x + y
add5 = adder(5)
add10 = adder(10)
assert(add5(3) == 8)
assert(add10(3) == 13)
assert(add5(7) == 12)
assert(add10(7) == 17)

# 테스트 7: Closure와 산술 연산
make_doubler = lambda x: lambda: x * 2
doubler = make_doubler(21)
assert(doubler() == 42)

# 테스트 8: 중첩에서 여러 변수 캡처
outer = lambda a, b: lambda c, d: a + b + c + d
middle = outer(1, 2)
assert(middle(3, 4) == 10)
